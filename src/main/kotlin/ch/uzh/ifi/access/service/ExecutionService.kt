package ch.uzh.ifi.access.service

import ch.uzh.ifi.access.Util
import ch.uzh.ifi.access.Util.bytesToString
import ch.uzh.ifi.access.model.*
import ch.uzh.ifi.access.model.constants.Command
import ch.uzh.ifi.access.model.dao.Results
import ch.uzh.ifi.access.repository.TaskFileRepository
import com.fasterxml.jackson.databind.json.JsonMapper
import com.github.dockerjava.api.DockerClient
import com.github.dockerjava.api.command.PullImageResultCallback
import com.github.dockerjava.api.command.WaitContainerResultCallback
import com.github.dockerjava.api.exception.NotFoundException
import com.github.dockerjava.api.model.Bind
import com.github.dockerjava.api.model.HostConfig
import io.github.oshai.kotlinlogging.KotlinLogging
import org.apache.commons.io.FileUtils
import org.springframework.stereotype.Service
import java.nio.charset.Charset
import java.nio.file.Files
import java.nio.file.NoSuchFileException
import java.nio.file.Path
import java.util.concurrent.CompletableFuture
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

@Service
class ExecutionService(
    private val dockerClient: DockerClient,
    private val fileService: FileService,
    private val workingDir: Path,
    private val taskFileRepository: TaskFileRepository,
    private val jsonMapper: JsonMapper,
    private val courseService: CourseService,
) {
    private val logger = KotlinLogging.logger {}

    fun executeTemplate(task: Task): Pair<Submission, Results> {
        val course = task.assignment?.course ?: task.course!!
        val submission = Submission()
        submission.command = Command.GRADE
        val visible = getVisibleFiles(task.id)
        submission.files = getVisibleFiles(task.id).map { it ->
            val file = SubmissionFile()
            file.content = it.template
            file.taskFile = it
            file.submission = submission
            file
        }.toMutableList()
        val evaluation = Evaluation()
        evaluation.remainingAttempts = 1
        evaluation.task = task
        submission.evaluation = evaluation
        return executeSubmission(course, submission, task, evaluation)
    }

    fun executeSubmission(
        course: Course,
        submission: Submission,
        task: Task,
        evaluation: Evaluation
    ): Pair<Submission, Results> {
        var results = Results()
        val image = task.dockerImage!!
        // inspect the image to check whether it's local, and pull it if necessary
        try {
            dockerClient.inspectImageCmd(image).exec()
        } catch (e: NotFoundException) {
            dockerClient.pullImageCmd(image)
                .exec(PullImageResultCallback())
                .awaitCompletion()
        }
        val folderId = submission.id.toString() ?: java.util.UUID.randomUUID().toString()

        // calculate the embedding in parallel with running the code.
        val embeddingFuture: CompletableFuture<List<Double>?> =
            if (isExample(task) && (submission.command == Command.GRADE)) {
                CompletableFuture.supplyAsync {
                    // Assumption: A submission for an example always consists of only one file, which is the student implementation (to remain language-agnostic
                    // No testing file for examples / no multi-file examples.
                    if (submission.files.size == 1) {
                        val implementation = submission.files[0].content ?: ""
                        courseService.getImplementationEmbedding(implementation)
                    } else {
                        logger.debug { "More than one file found in the task directory of the submission. It is not clear which file contains the student code." }
                        null
                    }
                }
            } else {
                CompletableFuture.completedFuture(null)
            }

        dockerClient.createContainerCmd(image).use { containerCmd ->
            val submissionDir = workingDir.resolve("submissions").resolve(folderId)
            // add submission files (supplied by the frontend) to the container
            submission.files.forEach { file -> writeSubmissionFile(submissionDir, file) }
            // add visible but non-editable files (these are not part of the submission files, but part of the task)
            getVisibleNonEditableFiles(task.id).forEach { file: TaskFile -> writeTaskFile(submissionDir, file) }
            // add grading and course global files if submission is graded
            if (submission.isGraded) {
                getGradingFiles(task.id).forEach { file: TaskFile -> writeTaskFile(submissionDir, file) }
                course.globalFiles.forEach { file -> writeGlobalFile(submissionDir, file) }
            }
            // student code is run on a tmpfs so we can enforce a disk quota
            val tmpfs: Map<String, String> = mapOf(
                "/workspace" to "size=50M",
            )
            // files generated by student code are limited in size
            val resultFileSizeLimit = 100 * Util.KILOBYTE
            // The bash snippets generated below are eventually put near the end of the docker execution script. For
            // each individual result file, one snippet is generated, which will validate and extract the result file.
            // If any result file is too large, the docker execution script will terminate with exit code 202
            val persistentFileCopyCommands = task.persistentResultFilePaths.joinToString("\n") { path ->
                """
                # Check if results file exceeds permissible size limit
                if [[ -f "$path" ]]; then
                    actual_size=${'$'}(stat -c%s "$path")
                    if [[ ! ${'$'}actual_size -lt $resultFileSizeLimit ]]; then
                        exit 202
                    fi
                fi
                # Copy the result file to the correct directory in the submission volume
                file_dir=${'$'}(dirname "$path")
                mkdir -p "/submission/${'$'}file_dir"
                cp "$path" "/submission/${'$'}file_dir" 
                """
            }
            // Generate the script which the docker container executes when started. It...
            //  * copies all the necessary files from the submission volume to the container tmpfs
            //  * runs the task submission command
            //  * stores the command output log
            //  * remembers the command exit code
            //  * copies the grading results JSON file and logs back to the submission volume
            //  * exits with exit code 201 if the tmpfs quota is exceeded
            //  * copies result files to the submission volume using the snippet generated above
            //  * exits with exit code 202 if the snippet above fails
            //  * exits with the command exit code if all else went well
            val command = (
            """
                # copy submitted files to tmpfs
                /bin/cp -R /submission/* /workspace/
                # run command (the cwd is set to /workspace already)
                ${task.formCommand(submission.command!!)} &> logs.txt
                # remember the command's exit code
                exit_code=${'$'}?; 
                # write results and logs to submission volume
                /bin/cp /workspace/grade_results.json /submission/
                /bin/cp /workspace/logs.txt /submission/
                # check if the tmpfs is full and if so, return 201
                USAGE=${'$'}(df -h | grep /workspace | awk '{print ${'$'}5}' | sed 's/%//')
                if [ "${'$'}USAGE" -eq 100 ]; then
                    exit 201
                fi
                # otherwise check and copy persistent results and return command status code
                $persistentFileCopyCommands
                exit ${'$'}exit_code;
                """.trimIndent()
            )
            // create the container
            val memoryLimit = 250 * Util.MEGABYTE
            val container = containerCmd
                .withLabels(mapOf("userId" to submission.userId)).withWorkingDir("/workspace")
                .withCmd("/bin/bash", "-c", command)
                .withHostConfig(
                    HostConfig()
                        .withTmpFs(tmpfs)
                        .withMemory(memoryLimit)
                        .withBinds(Bind.parse("$submissionDir:/submission"))
                ).exec()
            // Set up a scheduler to kill the container forcefully after the specified task timeout (or 180 seconds at
            // most). This is necessary if the submission is in an endless loop or similar lock-up.
            val scheduler = Executors.newScheduledThreadPool(1)
            val timeout = task.timeLimit.coerceAtMost(180).toLong()
            var killedContainer = false
            scheduler.schedule({
                try {
                    dockerClient.stopContainerCmd(container.id).withTimeout(0).exec()
                    killedContainer = true
                    logger.debug { "Forcefully killed container ${container.id} after $timeout seconds" }
                } catch (_: Exception) {
                    // if this fails it just means that the container is already dead, no worries
                }
            }, timeout, TimeUnit.SECONDS)
            // start the container
            dockerClient.startContainerCmd(container.id).exec()
            // wait for the container to terminate
            val statusCode = dockerClient.waitContainerCmd(container.id)
                .exec(WaitContainerResultCallback())
                .awaitStatusCode()
            // we can get rid of the scheduler now, because the container is dead for sure
            dockerClient.removeContainerCmd(container.id).exec()
            scheduler.shutdown()
            logger.debug { "Submission $submissionDir finished with statusCode $statusCode" }
            // time to collect the execution results
            submission.logs = readLogsFile(submissionDir)
            val persistentResultFileErrors: MutableList<String> = mutableListOf()
            task.persistentResultFilePaths.forEach { path ->
                try {
                    val resultFile = fileService.storeFile(submissionDir.resolve(path), ResultFile())
                    resultFile.path = path
                    resultFile.submission = submission
                    submission.persistentResultFiles.add(resultFile)
                } catch (e: Exception) {
                    persistentResultFileErrors.add("A file '$path' should have been created, but wasn't.")
                }
            }
            if (submission.isGraded) {
                results = when (statusCode) {
                    // out of memory
                    137 -> {
                        logger.debug { "Submission $submissionDir exit code is 137 (out of memory)" }
                        if (killedContainer) {
                            logger.debug { "Submission $submissionDir killed due to timeout" }
                            Results(
                                0.0,
                                mutableListOf("Your solution ran out of time (taking more than $timeout seconds). Check for infinite loops and ensure your solution is sufficiently fast even for challenging problem parameters.")
                            )
                        } else {
                            logger.debug { "Submission $submissionDir out of memory" }
                            Results(
                                0.0,
                                mutableListOf(
                                    "Your solution ran out of memory (using more than ${
                                        bytesToString(
                                            memoryLimit
                                        )
                                    }). Make sure you aren't creating gigantic data structures."
                                )
                            )
                        }
                    }
                    // out of tmpfs disk space
                    201 -> {
                        Results(
                            0.0,
                            mutableListOf(
                                "Your solution wrote too much data (more than ${
                                    bytesToString(
                                        resultFileSizeLimit
                                    )
                                }), either to files, or by printing to the command line. Are you printing in an infinite loop?"
                            )
                        )
                    }
                    // persistent result file too large
                    202 -> {
                        Results(
                            0.0,
                            mutableListOf(
                                "One or more files you're supposed to write exceeds the file size limit of ${
                                    bytesToString(
                                        resultFileSizeLimit
                                    )
                                }"
                            )
                        )
                    }
                    // None of the above, hopefully there are grading results.
                    // If there are no grading results now, that's a bug in the task grading code, not in ACCESS!
                    else -> {
                        try {
                            jsonMapper.readValue(
                                Files.readString(submissionDir.resolve("grade_results.json")),
                                Results::class.java
                            )
                        } catch (e: NoSuchFileException) {
                            logger.debug { "Submission $submissionDir no grade_results.json" }
                            Results(
                                null,
                                mutableListOf("No grading results. Please report this to the course organizers or teaching assistants and provide as much detail as possible.")
                            )
                        }
                    }
                }
                results.hints.addAll(persistentResultFileErrors)
                submission.output = results.hints.filterNotNull().firstOrNull()
                if (results.points != null) {
                    // only relevant for GRADE submissions (RUN and TEST are always valid)
                    submission.valid = true
                    submission.testsPassed = results.hints.map { hint ->
                        if (hint == null) 1 else 0
                    }
                    /*submission.testScores = results.testScores*/
                    // never go over 100%; the number of points is otherwise up to the test suite to determine correctly
                    submission.points = minOf(results.points!!, submission.maxPoints!!)
                    evaluation.update(submission.points)
                }
            }
            FileUtils.deleteQuietly(submissionDir.toFile())
        }
        try {
            val embedding = embeddingFuture.join()
            if (embedding != null) {
                submission.embedding = embedding
            }
        } catch (e: Exception) {
            logger.debug { "Failed to get embedding after : ${e.message}" }
        }
        return Pair(submission, results)
    }

    private fun writeFileData(filePath: Path, data: String?, binaryData: ByteArray?) {
        if (binaryData != null) {
            Files.write(filePath, binaryData)
        } else if (data != null) {
            Files.writeString(filePath, data)
        }
    }

    // creates necessary directories to prepare for writing
    private fun touchFile(submissionDir: Path, relativePath: String): Path {
        val unrootedFilePath = relativePath.substring(1)
        val filePath = submissionDir.resolve(unrootedFilePath)
        Files.createDirectories(filePath.parent)
        if (!filePath.toFile().exists()) Files.createFile(filePath)
        return filePath
    }

    private fun writeSubmissionFile(submissionDir: Path, submissionFile: SubmissionFile) {
        val filePath = touchFile(submissionDir, submissionFile.taskFile!!.path!!)
        writeFileData(filePath, submissionFile.content, null)
    }

    private fun writeTaskFile(submissionDir: Path, taskFile: TaskFile) {
        val filePath = touchFile(submissionDir, taskFile.path!!)
        writeFileData(filePath, taskFile.template, taskFile.templateBinary)
    }

    private fun writeGlobalFile(submissionDir: Path, globalFile: GlobalFile) {
        val filePath = touchFile(submissionDir, globalFile.path!!)
        writeFileData(filePath, globalFile.template, globalFile.templateBinary)
    }

    fun getGradingFiles(taskId: Long?): List<TaskFile> {
        return taskFileRepository.findByTask_IdAndEnabledTrue(taskId)
            .filter { file: TaskFile -> file.grading }
            .toList()
    }

    fun getVisibleFiles(taskId: Long?): List<TaskFile> {
        return taskFileRepository.findByTask_IdAndEnabledTrue(taskId)
            .filter { file: TaskFile -> file.visible }
            .toList()
    }

    fun getVisibleNonEditableFiles(taskId: Long?): List<TaskFile> {
        return taskFileRepository.findByTask_IdAndEnabledTrue(taskId)
            .filter { file: TaskFile -> file.visible && !file.editable }
            .toList()
    }

    fun isExample(task: Task): Boolean {
        return task.course != null
    }

    private fun readLogsFile(path: Path): String {
        val logsFile = path.resolve("logs.txt").toFile()

        return if (!logsFile.exists()) {
            listOf("no log file")
        } else {
            val lines = FileUtils.readLines(logsFile, Charset.defaultCharset())
            when {
                lines.size > 100 -> lines.take(50) + "[... ${lines.size - 100} more lines ...]" + lines.takeLast(50)
                else -> lines
            }
        }.joinToString(separator = "\n").replace("\u0000", "") // null characters mess up transport
    }


}
